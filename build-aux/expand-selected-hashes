#! /usr/bin/perl
# Written by Zack Weinberg <zackw at panix.com> in 2018 and 2020.
# To the extent possible under law, Zack Weinberg has waived all
# copyright and related or neighboring rights to this work.
#
# See https://creativecommons.org/publicdomain/zero/1.0/ for further
# details.

# Using the information in lib/hashes.conf, validate a list of
# selected hashes and hash groups that was supplied as the argument of
# the --enable-hashes option to the configure script, expand all
# the groups, and remove duplicates.
#
# Caution: if you change the format of lib/hashes.conf you will
# probably need to modify gen-crypt-hashes-h as well as this script.

use v5.14;  # implicit use strict, use feature ':5.14'
use warnings FATAL => 'all';
use utf8;
use open qw(:std :utf8);
no  if $] >= 5.022, warnings => 'experimental::re_strict';
use if $] >= 5.022, re => 'strict';

# Get the list of all supported hashes and the membership of each hash
# group.  Does not check for errors in hashes.conf; gen-crypt-hashes-h
# handles that.
sub read_hashes_conf {
    my ($hashes_conf) = @_;
    my %hashes;
    my %groups;
    local $_;

    open my $fh, '<', $hashes_conf
        or die "$hashes_conf: $!\n";
    while (<$fh>) {
        next if /^#/;
        chomp;
        s/\s+$//;
        next if /^$/;

        my ($h, undef, undef, $flags) = split;
        $hashes{$h} = 1;
        for my $flag (split /,/, $flags) {
            $flag = lc $flag;
            # 'default' is the only flag that isn't a selection group.
            if ($flag ne 'default') {
                $groups{$flag} = []  unless exists $groups{$flag};
                push @{$groups{$flag}}, $h;
            }
        }
    }
    return \%hashes, \%groups;
}

sub expand_selected {
    my ($hashes, $groups, $selected) = @_;

    if ($selected eq 'all') {
        return keys %$hashes;
    } else {
        my %enabled;
        my @errors;
        for my $w (split /,/, $selected) {
            if ($w eq 'all') {
                push @errors, "'all' must be used alone\n";
            } elsif (exists $hashes->{$w}) {
                $enabled{$w} = 1;
            } elsif (exists $groups->{$w}) {
                for my $h (@{$groups->{$w}}) {
                    $enabled{$h} = 1;
                }
            } else {
                push @errors, "'$w' is not a hash or group name\n";
            }
        }
        die join("", @errors) if @errors;
        return keys %enabled;
    }
}

#
# Main
#
my $ME = $0; $ME =~ s:^.+?/([^/]+)$:$1:;
if (scalar(@ARGV) != 2) {
    print STDERR "usage: $ME hashes.conf names,of,selected,hashes\n";
    exit 1;
}
eval {
    my ($hashes_conf, $hashes_selected) = @ARGV;
    my ($hashes, $groups) = read_hashes_conf($hashes_conf);
    my @enabled = expand_selected($hashes, $groups, $hashes_selected);

    print ",", join(",", sort @enabled), ",\n";
    close STDOUT or die "write error: $!\n";
};
if ($@) {
    print STDERR "$ME: $@";
    exit 1;
}
exit 0;
