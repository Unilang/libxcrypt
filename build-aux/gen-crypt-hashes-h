#! /usr/bin/perl
# Written by Zack Weinberg <zackw at panix.com> in 2018 and 2020.
# To the extent possible under law, Zack Weinberg has waived all
# copyright and related or neighboring rights to this work.
#
# See https://creativecommons.org/publicdomain/zero/1.0/ for further
# details.

# Generate crypt-hashes.h from lib/hashes.conf and configure settings.
# Also responsible for checking lib/hashes.conf for errors.
#
# Caution: if you change the format of lib/hashes.conf you will
# probably need to modify expand-selected-hashes as well as this script.

use v5.14;  # implicit use strict, use feature ':5.14'
use warnings FATAL => 'all';
use utf8;
use open qw(:std :utf8);
no  if $] >= 5.022, warnings => 'experimental::re_strict';
use if $] >= 5.022, re => 'strict';

# The canonical list of flags that can appear in the fourth field
# of a hashes.conf entry.  Alphabetical, except for STRONG and
# DEFAULT.
my @VALID_FLAGS = qw(
    STRONG DEFAULT
    ALT
    FEDORA
    FREEBSD
    GLIBC
    NETBSD
    OPENBSD
    OSX
    OWL
    SOLARIS
    SUSE
);

#
# State used only while parsing hashes.conf.
#
package parser {
    our $maxnamelen = 0;
    our $error = 0;

    my %valid_flags = map { $_ => 1 } @VALID_FLAGS;
    my $fname;

    sub err ($;$) {
        my ($line, $msg) = @_;
        if (!defined $msg) {
            $msg = $line;
            $line = $.;
        }
        print STDERR "$fname:$line: error: $msg\n";
        $error = 1;
    }

    sub note ($;$) {
        my ($line, $msg) = @_;
        if (!defined $msg) {
            $msg = $line;
            $line = $.;
        }
        print STDERR "$fname:$line: note: $msg\n";
    }

    sub parse_hashes_conf {
        ($fname) = @_;
        open my $fh, '<', $fname
            or die "$fname: $!\n";

        my %line_of;
        my @all_hashes;
        local $_;
        while (<$fh>) {
            next if /^#/;
            chomp;
            s/\s+$//;
            next if /^$/;

            my @fields = split;
            if (scalar(@fields) != 4) {
                err 'wrong number of fields';
                next;
            }
            my ($name, $h_prefix, $nrbytes, $flags) = @fields;
            my $default_cand = 0;
            my $is_strong = 0;

            if ($name eq ':') {
                err 'method name cannot be blank';
                $name="_missing_$.";
            }

            # No two hashing method names can be the same.
            if (exists $line_of{$name}) {
                err "method name '$name' reused";
                note $line_of{$name}, 'previous use was here';
            } else {
                $line_of{$name} = $.;
                $maxnamelen = length $name if $maxnamelen < length $name;
            }

            $h_prefix = '' if $h_prefix eq ':';

            if ($nrbytes !~ /^[0-9]+$/ || $nrbytes == 0) {
                err 'nrbytes must be a positive integer';
                $nrbytes = 1;
            }

            $flags = '' if $flags eq ':';
            for (split /,/, $flags) {
                if (!exists $valid_flags{$_}) {
                    err "unrecognized flag $_";
                } else {
                    if ($_ eq 'DEFAULT') {
                        $default_cand = 1;
                    } elsif ($_ eq 'STRONG') {
                        $is_strong = 1;
                    }
                }
            }
            if ($default_cand && !$is_strong) {
                err "weak hash marked as default candidate";
            }

            push @all_hashes, [$name, $h_prefix, $nrbytes, $default_cand];
        }

        # No hash prefix can be a prefix of any other hash prefix, except
        # for the empty prefix.
        for my $a (@all_hashes) {
            my ($ha, $pa, undef, undef) = @$a;
            next if $pa eq '';
            for my $b (@all_hashes) {
                my ($hb, $pb, undef, undef) = @$b;
                next if $ha eq $hb;
                next if $pb eq '';
                if ($pb =~ /^\Q$pa\E/) {
                    err $line_of{$hb},
                        "prefix collision: '$pb' begins with '$pa'";
                    note $line_of{$ha}, "'$pa' used for hash '$ha'";
                }
            }
        }
        return @all_hashes;
    }
}

sub output {
    my ($ME, $basehc, $hashes_enabled, $all_hashes) = @_;
    $basehc =~ s:^.*?/([^/]+)$:$1:;

    print <<EOT;
/* Generated by $ME from $basehc.  DO NOT EDIT.  */

#ifndef _CRYPT_HASHES_H
#define _CRYPT_HASHES_H 1

EOT

    my %enabled;
    for my $h (split /,/, $hashes_enabled) {
        $enabled{$h} = 1 unless $h eq '';
    }
    my @enabled_hashes;
    for (@$all_hashes) {
        my $h = ${$_}[0];
        my $e = $enabled{$h} // 0;
        printf("#define INCLUDE_%*s %d\n", -$parser::maxnamelen, $h, $e);
        push @enabled_hashes, $_ if $e;
    }

    print <<'EOT';

/* Internal symbol renames for static linkage, see crypt-port.h.  */
EOT

    for (@enabled_hashes) {
        my $h = ${$_}[0];
        print <<EOT;
#define crypt_${h}_rn _crypt_crypt_${h}_rn
#define gensalt_${h}_rn _crypt_gensalt_${h}_rn
EOT
    }

    print <<'EOT';

/* Prototypes for hash algorithm entry points.  */
EOT
    for (@enabled_hashes) {
        my $h = ${$_}[0];
        print <<EOT;
extern void crypt_${h}_rn (const char *, size_t, const char *,
                size_t, uint8_t *, size_t, void *, size_t);
extern void gensalt_${h}_rn (unsigned long,
                const uint8_t *, size_t, uint8_t *, size_t);
EOT
    }

    print <<'EOT';

#define HASH_ALGORITHM_TABLE_ENTRIES \
EOT
    my $default_prefix;
    for (@enabled_hashes) {
        my ($h, $p, $nr, $dc) = @{$_};
        printf("  { \"%s\", %d, crypt_%s_rn, gensalt_%s_rn, %s }, \\\n",
               $p, length($p), $h, $h, $nr);
        $default_prefix = $p  if $dc and !defined $default_prefix;
    }
    print "  { 0, 0, 0, 0, 0 }\n";

    print <<EOT if defined $default_prefix;

#define HASH_ALGORITHM_DEFAULT "$default_prefix"
EOT
    print <<'EOT';

#endif /* crypt-hashes.h */
EOT

    close STDOUT or die "write error: $!\n";
}

#
# Main
#
my $ME = $0; $ME =~ s:^.+?/([^/]+)$:$1:;
if (scalar(@ARGV) != 2) {
    print STDERR "usage: $0 hashes.conf ,names,of,enabled,hashes,\n";
    exit 1;
}
eval {
    my ($hashes_conf, $hashes_enabled) = @ARGV;
    my @all_hashes = parser::parse_hashes_conf($hashes_conf);
    exit 1 if $parser::error;
    output($ME, $hashes_conf, $hashes_enabled, \@all_hashes);
};
if ($@) {
    print STDERR "$ME: $@";
    exit 1;
}
exit 0;
