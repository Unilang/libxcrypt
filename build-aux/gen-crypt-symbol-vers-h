#! /usr/bin/perl
# Written by Zack Weinberg <zackw at panix.com> in 2017.
# To the extent possible under law, Zack Weinberg has waived all
# copyright and related or neighboring rights to this work.
#
# See https://creativecommons.org/publicdomain/zero/1.0/ for further
# details.

# Generate macros that control the symbol versions of the public
# library API, from a .map.in file.

use v5.14;  # implicit use strict, use feature ':5.14'
use warnings FATAL => 'all';
use utf8;
use open qw(:std :utf8);
no  if $] >= 5.022, warnings => 'experimental::re_strict';
use if $] >= 5.022, re => 'strict';

use List::Util qw(max);

# On the command line, we expect to see the name of the .map.in
# file plus the settings for the variables SYMVER_MIN, SYMVER_FLOOR,
# and COMPAT_ABI, in any order.
#
# See libcrypt.map.in for an explanation of the format of .map.in
# files.  See crypt-port.h for an explanation of how to use the macros
# generated by this program.
#
# Note: if you change the format of .map.in files you probably need to
# update gen-libcrypt-map too.
#
# Note: we currently don't support compatibility symbols that need
# a different definition from the default version.

sub parse_args {
    my $me = shift;
    my $map_in;
    my $SYMVER_MIN;
    my $SYMVER_FLOOR;
    my $COMPAT_ABI;

    local $_;
    local *usage_error = sub {
        print STDERR
            "$me: usage: SYMVER_MIN=value SYMVER_FLOOR=value ".
            "COMPAT_ABI=value libcrypt.map.in\n";
        exit 1;
    };

    usage_error() if scalar(@_) != 4;

    for (@_) {
        if (/^SYMVER_MIN=(.+)$/) {
            usage_error() if defined $SYMVER_MIN;
            $SYMVER_MIN = $1;
            next;
        }
        if (/^SYMVER_FLOOR=(.+)$/) {
            usage_error() if defined $SYMVER_FLOOR;
            $SYMVER_FLOOR = $1;
            next;
        }
        if (/^COMPAT_ABI=(.+)$/) {
            usage_error() if defined $COMPAT_ABI;
            $COMPAT_ABI = $1;
            next;
        }
        usage_error() if defined $map_in;
        $map_in = $_;
    }
    return $map_in, $SYMVER_MIN, $SYMVER_FLOOR, $COMPAT_ABI;
}

sub process_map_in {
    my ($map_in, $SYMVER_MIN, $SYMVER_FLOOR, $COMPAT_ABI) = @_;
    local $_;
    my %symbols;
    my %compat_only;
    my @vchain;
    my $error;
    open my $fh, '<', $map_in
        or die "$map_in: $!\n";

    while (<$fh>) {
        next if /^#/;
        chomp;
        s/\s+$//;
        next if /^$/;

        my @vers = split;
        my $sym = shift @vers;
        if ($sym eq '%chain') {
            for my $v (@vers) {
                if (grep { $_ eq $v } @vchain) {
                    print STDERR
                        "$map_in:$.: error: '$v' used twice in %chain\n";
                    $error = 1;
                    next;
                }
                push @vchain, $v;
            }
            next;
        }

        # Dash in the second field means there is no default version
        # for this symbol.
        if ($vers[0] eq '-') {
            $compat_only{$sym} = 1;
            shift @vers;
        } else {
            $compat_only{$sym} = 0;
        }

        for my $v (@vers) {
            # Each $v is a symbol version name followed by zero
            # or more compatibility tags, separated by colons.
            # If there are no tags, the symbol version is available
            # unconditionally; if there are any tags, the symbol
            # version is available if COMPAT_ABI is equal to 'yes'
            # or equal to one of the tags.
            my @tags = split /:/, $v;
            $v = shift @tags;
            if (@tags && $COMPAT_ABI ne 'yes') {
                my $enabled = 0;
                for my $t (@tags) {
                    if ($t eq $COMPAT_ABI) {
                        $enabled = 1;
                        last;
                    }
                }
                next unless $enabled;
            }
            $symbols{$v} = []
                unless exists $symbols{$v};
            push @{$symbols{$v}}, $sym;
        }
    }

    if (!@vchain) {
        print STDERR "$map_in: error: missing %chain directive\n";
        $error = 1;
    }

    my $symver_min_idx;
    my $symver_floor_idx;
    for (0 .. $#vchain) {
        if ($vchain[$_] eq $SYMVER_MIN) {
            $symver_min_idx = $_;
        }
        if ($vchain[$_] eq $SYMVER_FLOOR) {
            $symver_floor_idx = $_;
        }
        last if defined $symver_min_idx && defined $symver_floor_idx;
    }
    if (!defined $symver_min_idx) {
        print STDERR "$map_in: error: SYMVER_MIN ($SYMVER_MIN) ".
            'not found in %chain directives';
        $error = 1;
        $symver_min_idx = -2;
    }
    if (!defined $symver_floor_idx) {
        print STDERR "$map_in: error: SYMVER_FLOOR ($SYMVER_FLOOR) ".
            'not found in %chain directives';
        $error = 1;
        $symver_floor_idx = -1;
    }
    if ($symver_floor_idx < $symver_min_idx) {
        print STDERR "$map_in: error: SYMVER_FLOOR ($SYMVER_FLOOR) ".
            "is lower than SYMVER_MIN ($SYMVER_MIN)";
        $error = 1;
    }
    exit 1 if $error;
    return (\%symbols, \%compat_only, \@vchain,
            $symver_min_idx, $symver_floor_idx);
}

# Construct a pruned set of symbols and versions, including only
# versions with symbols, discarding all symbols associated with
# versions below SYMVER_MIN, raising symbols below SYMVER_FLOOR to
# SYMVER_FLOOR, and removing duplicates.
# Note: unlike in gen-libcrypt-map, symbols all of whose versions are
# below SYMVER_MIN must still be counted in 'allsyms' so their
# INCLUDE macros are generated.
sub prune_symbol_versions {
    my ($symbols, $vchain, $symver_min_idx, $symver_floor_idx) = @_;

    my %symset;
    my %allsymset;
    for my $i (0 .. $#{$vchain}) {
        my $syms = $symbols->{$vchain->[$i]};
        next unless defined $syms;

        my $vr = $vchain->[$i > $symver_floor_idx ? $i : $symver_floor_idx];
        for my $s (@$syms) {
            $allsymset{$s} = 1;
            if ($i >= $symver_min_idx) {
                $symset{"$s:$vr"} = 1;
            }
        }
    }
    my @allsyms = sort keys %allsymset;
    return \%symset, \@allsyms;
}

sub output {
    my ($me, $basemap, $symset, $allsyms, $compat_only,
        $vchain, $symver_floor_idx) = @_;

    $basemap =~ s:^.+?/([^/]+)$:$1:;

    print "/* Generated from $basemap by $me.  DO NOT EDIT.  */\n";
    print <<'EOT';

#ifndef _CRYPT_SYMBOL_VERS_H
#define _CRYPT_SYMBOL_VERS_H 1

/* For each public symbol <sym>, INCLUDE_<sym> is true if it
   has any versions above the backward compatibility minimum.
   Compatibility-only symbols are not included in the static
   library, or in the shared library when configured with
   --disable-obsolete-api.  */
#if defined PIC && ENABLE_OBSOLETE_API

EOT

    my %includesym;
    my $maxsymlen = max(map(length, @$allsyms));
    for my $sym (@$allsyms) {
        my $include = 0;
        for my $v (@{$vchain}[$symver_floor_idx .. $#{$vchain}]) {
            if (exists $symset->{"$sym:$v"}) {
                $include = 1;
                last;
            }
        }
        printf("#define INCLUDE_%-*s %d\n", $maxsymlen, $sym, $include);
        $includesym{$sym} = $include;
    }
    print "\n#else\n\n";
    for my $sym (@$allsyms) {
        printf("#define INCLUDE_%-*s %d\n", $maxsymlen, $sym,
               $includesym{$sym} && !$compat_only->{$sym});
    }

    print <<'EOT';

#endif

/* When the public symbols are being given versions, they must be
   defined under a different, private name first.  */
#ifdef PIC
EOT

    for my $sym (@$allsyms) {
        printf("#define %-*s _crypt_%s\n", $maxsymlen, $sym, $sym)
            if $includesym{$sym} || $compat_only->{$sym};
    }

    print <<'EOT';
#endif

/* For each public symbol <sym> that is included, define its
   highest version as the default, and aliases at each
   compatibility version. */
EOT

    my @rvchain = reverse @{$vchain}[$symver_floor_idx .. $#{$vchain}];
    for my $sym (@$allsyms) {
        if (!$includesym{$sym}) {
            print "#define SYMVER_$sym symver_nop()\n";
            next;
        }

        my $seq = 0;
        for my $v (@rvchain) {
            next unless exists $symset->{"$sym:$v"};
            if ($seq == 0) {
                print "#define SYMVER_$sym \\\n";
                if ($compat_only->{$sym}) {
                    print "  symver_compat0 (\"$sym\", $sym, $v)";
                } else {
                    print "  symver_default (\"$sym\", $sym, $v)";
                }
            } else {
                print
                    "; \\\n".
                    "  symver_compat ($seq, \"$sym\", $sym, $sym, $v)";
            }
            $seq++;
        }
        print "\n";
    }

    print <<'EOT';

#endif /* crypt-symbol-vers.h */
EOT

    close STDOUT or die "write error: $!\n";
}

#
# Main
#
my $ME = $0; $ME =~ s:^.+?/([^/]+)$:$1:;
eval {
    my ($map_in, $SYMVER_MIN, $SYMVER_FLOOR, $COMPAT_ABI)
        = parse_args($ME, @ARGV);

    my ($symbols, $compat_only, $vchain, $symver_min_idx, $symver_floor_idx)
        = process_map_in($map_in, $SYMVER_MIN, $SYMVER_FLOOR, $COMPAT_ABI);

    my ($symset, $allsyms)
        = prune_symbol_versions($symbols, $vchain,
                                $symver_min_idx, $symver_floor_idx);

    output($ME, $map_in, $symset, $allsyms, $compat_only,
           $vchain, $symver_floor_idx);
};
if ($@) {
    print STDERR "$ME: $@";
    exit 1;
}
exit 0;
